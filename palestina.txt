

// setup.js
// Stats: "Auth" : '["0-Games", "1-Wins", "2-Draws", "3-Losses", "4-Winrate", "5-Goals", "6-Assists", "7-GK", "8-CS", "9-CS%", "10- ELO", "11-Role", "12-Nick"]'

/* VARIABLES */

/* ROOM */

const Bot = "Alis Pokva: "; // Bot's name

// GLOBAL VARIABLES //
const roomName = "♻ SNIPER VIP | CON ARDILLA ♻";
const botName ="ardillita loca";
const maxPlayers = 4;
const roomPublic = true;

// GEOLOCALIZATION //
const geo = [{"code": "PS", "lat": 40, "lon": -3}];

// Admin password //
var adminPassword = 4321;

const room = HBInit({ roomName: roomName, maxPlayers: maxPlayers, public: roomPublic, playerName: botName, geo: geo[0] });

// GAME SETTINGS //
const scoreLimitClassic = 3;
const timeLimitClassic = 1;

room.setTeamsLock(true);

var player_size = 15;


// maps.js
/* STADIUM */

const playerRadius = 15;
var ballRadius = 6.25;
const triggerDistance = playerRadius + ballRadius + 0.01;
var aloneMap = '{"name":"F","width":620,"height":270,"cameraWidth":0,"cameraHeight":0,"maxViewWidth":0,"cameraFollow":"ball","spawnDistance":140,"redSpawnPoints":[],"blueSpawnPoints":[],"canBeStored":true,"kickOffReset":"partial","bg":{"color":"555555","height":120,"width":140,"type":"hockey","cornerRadius":0,"kickOffRadius":0},"traits":{"ballArea":{"vis":false,"bCoef":1,"cMask":["ball"]},"goalPost":{"radius":8,"invMass":0,"bCoef":0.5},"goalNet":{"vis":true,"bCoef":0.1,"cMask":["ball"]},"kickOffBarrier":{"vis":false,"bCoef":0.1,"cGroup":["redKO","blueKO"],"cMask":["red","blue"]}},"vertexes":[{"x":140,"y":-120,"cMask":["ball"],"trait":"ballArea","vis":true,"color":"FFFFFF"},{"x":140,"y":120,"cMask":["ball"],"trait":"ballArea","vis":true,"color":"FFFFFF"},{"x":-140,"y":-120,"trait":"ballArea","vis":true,"color":"FFFFFF"},{"x":-140,"y":122.22222222222221,"trait":"ballArea","vis":true,"color":"FFFFFF"},{"x":-139.7440593141879,"y":120,"trait":"ballArea","vis":true,"color":"FFFFFF"},{"x":0,"y":-120.88477366255142,"bCoef":1,"cMask":["wall"],"trait":"ballArea","color":"FFFFFF"},{"x":0,"y":120.88477366255142,"bCoef":1,"cMask":["wall"],"trait":"ballArea","color":"FFFFFF"},{"x":-140,"y":-124.6695036437032,"bCoef":1,"cMask":["wall"],"trait":"ballArea"},{"x":-140,"y":-140.87567140268303,"bCoef":1,"cMask":["wall"],"trait":"ballArea"},{"x":120,"y":-138.7294159768704,"bCoef":1,"cMask":["wall"],"trait":"ballArea"},{"x":120,"y":-122.96733072857592,"bCoef":1,"cMask":["wall"],"trait":"ballArea"},{"x":147.5,"y":-120.64617986166415,"bCoef":1,"cMask":["ball"],"trait":"ballArea","curve":0,"vis":false},{"x":147.5,"y":120,"bCoef":1,"cMask":["ball"],"trait":"ballArea","curve":0,"vis":false},{"x":-147.5,"y":-123.12000000000002,"bCoef":1,"cMask":["ball"],"trait":"ballArea","vis":false},{"x":-147.5,"y":122.04000000000002,"bCoef":1,"cMask":["ball"],"trait":"ballArea","vis":false},{"x":0,"y":-54.629629629629626,"bCoef":1,"cMask":["wall"],"trait":"ballArea","curve":190},{"x":0,"y":56.48148148148148,"bCoef":1,"cMask":["wall"],"trait":"ballArea","curve":190},{"x":0,"y":56.88126134608165,"bCoef":1,"cMask":["wall"],"trait":"ballArea","curve":190},{"x":-0.19865574759634885,"y":-54.69293035895264,"bCoef":1,"cMask":["wall"],"trait":"ballArea","curve":190}],"segments":[{"v0":0,"v1":1,"vis":true,"color":"FFFFFF","cMask":["ball"],"trait":"ballArea","x":140},{"v0":2,"v1":3,"vis":true,"color":"FFFFFF","trait":"ballArea","x":-140},{"v0":4,"v1":1,"vis":true,"color":"FFFFFF","trait":"ballArea","y":120},{"v0":2,"v1":0,"vis":true,"color":"FFFFFF","trait":"ballArea","y":-120},{"v0":5,"v1":6,"vis":true,"color":"FFFFFF","bCoef":1,"cMask":["wall"],"trait":"ballArea","x":0},{"v0":11,"v1":12,"curve":0,"vis":false,"color":"FFFFFF","bCoef":1,"cMask":["ball"],"trait":"ballArea","x":147.5},{"v0":13,"v1":14,"vis":false,"color":"FFFFFF","bCoef":1,"cMask":["ball"],"trait":"ballArea","x":-147.5},{"v0":15,"v1":16,"curve":190,"vis":true,"color":"FFFFFF","bCoef":1,"cMask":["wall"],"trait":"ballArea","x":0},{"v0":17,"v1":18,"curve":190,"vis":true,"color":"FFFFFF","bCoef":1,"cMask":["wall"],"trait":"ballArea","x":0}],"goals":[],"discs":[],"planes":[{"normal":[0,1],"dist":-122,"bCoef":1,"cMask":["ball"],"trait":"ballArea"},{"normal":[0,-1],"dist":-122,"bCoef":1,"cMask":["ball"],"trait":"ballArea"}],"joints":[],"playerPhysics":{"radius":15,"bCoef":0.5,"invMass":0.5,"damping":0.96,"cGroup":["red","blue"],"acceleration":0.1,"gravity":[0,0],"kickingAcceleration":0.083,"kickingDamping":0.96,"kickStrength":5,"kickback":0},"ballPhysics":{"radius":6.4,"bCoef":0.4,"cMask":["all"],"damping":0.99,"invMass":1.5,"gravity":[0,0],"color":"FFF000","cGroup":["ball"]}}'
var classicMap = '{"name":"S2","width":425,"height":200,"spawnDistance":170,"bg":{"type":"hockey","width":0,"height":0,"kickOffRadius":0,"cornerRadius":0},"vertexes":[{"x":-370,"y":170,"trait":"ballArea"},{"x":-370,"y":-170,"trait":"ballArea"},{"x":370,"y":-170,"trait":"ballArea"},{"x":0,"y":-170,"cMask":["wall"],"trait":"kickOffBarrier","color":"FFFFFF"},{"x":-371,"y":-144,"trait":"goalNet","curve":-190,"color":"ff0000"},{"x":-375,"y":-105,"trait":"goalNet","curve":-190,"color":"ff0000"},{"x":370,"y":-143,"trait":"goalNet","curve":190,"color":"ff0000"},{"x":370,"y":-106,"trait":"goalNet","curve":190,"color":"ff0000"},{"x":-370,"y":-38,"bCoef":1,"trait":"goalNet","curve":-190,"color":"FFFFFF"},{"x":-374,"y":35,"trait":"goalNet","curve":-190,"color":"ffffff"},{"x":-375,"y":105,"trait":"goalNet","curve":-190,"color":"ff0000"},{"x":-371,"y":143,"trait":"goalNet","curve":-190,"color":"ff0000"},{"x":50,"y":-200,"bCoef":0.1,"cMask":["blue"],"cGroup":["redKO"],"trait":"kickOffBarrier","curve":0,"vis":true,"color":"000000"},{"x":50,"y":200,"bCoef":0.1,"cMask":["blue"],"cGroup":["redKO"],"trait":"kickOffBarrier","curve":0,"vis":true,"color":"000000"},{"x":370,"y":104,"trait":"goalNet","curve":190,"color":"ff0000"},{"x":370,"y":142,"trait":"goalNet","curve":190,"color":"ff0000"},{"x":370,"y":-37,"trait":"goalNet","curve":190,"color":"ffffff"},{"x":370,"y":39,"trait":"goalNet","curve":190,"color":"ffffff"},{"x":370,"y":142,"bCoef":1,"cMask":["ball"],"trait":"goalNet","curve":0,"vis":false},{"x":370,"y":170,"bCoef":1.4,"cMask":["ball"],"trait":"goalNet","curve":0,"vis":false,"color":"ffffff"},{"x":-370,"y":146,"bCoef":1.5,"cMask":["ball"],"trait":"goalNet","curve":0,"vis":false},{"x":-370,"y":170,"bCoef":1.5,"cMask":["ball"],"trait":"goalNet","curve":0,"vis":false},{"x":-370,"y":145,"bCoef":1,"cMask":["ball"],"trait":"goalNet","curve":0,"vis":false},{"x":-370,"y":170,"bCoef":1.4,"cMask":["ball"],"trait":"goalNet","curve":0,"vis":false,"color":"ffffff"},{"x":-370,"y":-103,"bCoef":1,"cMask":["ball"],"trait":"goalPost","curve":1},{"x":-371,"y":-34,"bCoef":1,"cMask":["ball"],"trait":"goalPost","curve":1},{"x":-370,"y":-170,"bCoef":1.4,"cMask":["ball"],"trait":"goalNet","color":"ffffff"},{"x":-371,"y":-143,"bCoef":1.5,"cMask":["ball"],"trait":"goalPost"},{"x":-370,"y":37,"bCoef":1,"cMask":["ball"],"trait":"goalNet","color":"ffffff"},{"x":-370,"y":99,"bCoef":1,"cMask":["ball"],"trait":"goalNet","color":"ffffff"},{"x":370,"y":-170,"bCoef":1.4,"cMask":["ball"],"trait":"goalNet","color":"ffffff"},{"x":370,"y":-145,"bCoef":1.52,"cMask":["ball"],"trait":"goalPost"},{"x":370,"y":-104,"bCoef":1,"cMask":["ball"],"trait":"goalPost"},{"x":371,"y":-37,"bCoef":1,"cMask":["ball"],"trait":"goalPost"},{"x":-50,"y":-200,"bCoef":0.1,"cMask":["red"],"cGroup":["blueKO"],"trait":"goalPost","curve":0,"vis":true,"color":"000000"},{"x":-50,"y":200,"bCoef":0.1,"cMask":["red"],"cGroup":["blueKO"],"trait":"goalPost","curve":0,"vis":true,"color":"000000"},{"x":370,"y":-152,"bCoef":1,"trait":"goalNet","color":"ffffff"},{"x":-370,"y":-152,"bCoef":1,"cMask":["ball"],"trait":"goalNet","color":"ffffff"},{"x":-370,"y":-95,"bCoef":1,"cMask":["ball"],"trait":"goalNet","color":"FFFFFF"},{"x":370,"y":152,"bCoef":1,"cMask":["ball"],"trait":"goalNet","color":"ffffff"},{"x":370,"y":-96,"bCoef":1,"trait":"goalNet","color":"ffffff"},{"x":370,"y":-44,"bCoef":1,"trait":"goalNet","color":"ffffff"},{"x":-370,"y":153,"bCoef":1,"trait":"goalNet","color":"ffffff"},{"x":370,"y":49,"bCoef":1,"trait":"goalNet","color":"ffffff"},{"x":370,"y":96,"bCoef":1,"trait":"goalNet","color":"ffffff"},{"x":0,"y":170,"bCoef":0.1,"cMask":["wall"],"color":"FFFFFF"},{"x":-370,"y":-144,"trait":"goalNet","curve":0,"vis":false},{"x":-370,"y":-105,"trait":"goalNet","curve":0,"vis":false},{"x":-370,"y":-38,"bCoef":1,"trait":"goalNet","curve":0,"color":"000000","vis":false},{"x":-370,"y":35,"trait":"goalNet","curve":0,"vis":false},{"x":-370,"y":105,"trait":"goalNet","curve":0,"vis":false},{"x":-370,"y":143,"trait":"goalNet","curve":0,"vis":false},{"x":50,"y":-200,"bCoef":0.1,"cMask":["red"],"cGroup":["red"],"trait":"goalPost","curve":0,"vis":true,"color":"F0FF0F"},{"x":50,"y":200,"bCoef":0.1,"cMask":["red"],"cGroup":["red"],"trait":"goalPost","curve":0,"vis":true,"color":"F0FF0F"},{"x":-50,"y":-200,"bCoef":0.1,"cMask":["blue"],"cGroup":["blue"],"trait":"goalPost","curve":0,"vis":true,"color":"F0FF0F"},{"x":-50,"y":200,"bCoef":0.1,"cMask":["blue"],"cGroup":["blue"],"trait":"goalPost","curve":0,"vis":true,"color":"F0FF0F"}],"segments":[{"v0":4,"v1":5,"curve":-190,"color":"FFFFFF","trait":"goalNet"},{"v0":6,"v1":7,"curve":190,"color":"FFFFFF","trait":"goalNet","x":370},{"v0":8,"v1":9,"curve":-190,"color":"FFFFFF","trait":"goalNet"},{"v0":10,"v1":11,"curve":-190,"color":"FFFFFF","trait":"goalNet"},{"v0":12,"v1":13,"curve":0,"vis":true,"color":"FFFFFF","bCoef":0.1,"cMask":["blue"],"cGroup":["redKO"],"trait":"kickOffBarrier"},{"v0":14,"v1":15,"curve":190,"color":"FFFFFF","trait":"goalNet","x":370},{"v0":16,"v1":17,"curve":190,"color":"ffffff","trait":"goalNet","x":370},{"v0":18,"v1":19,"curve":0,"vis":false,"color":"FFCCCC","bCoef":1,"cMask":["ball"],"trait":"goalNet"},{"v0":20,"v1":21,"curve":0,"vis":false,"color":"FFCCCC","bCoef":1.5,"cMask":["ball"],"trait":"goalNet"},{"v0":22,"v1":23,"curve":0,"vis":false,"color":"FFCCCC","bCoef":1,"cMask":["ball"],"trait":"goalNet"},{"v0":24,"v1":25,"curve":1,"vis":false,"color":"FFCCCC","bCoef":1,"cMask":["ball"],"trait":"goalPost"},{"v0":28,"v1":29,"curve":0,"vis":false,"color":"FFCCCC","bCoef":1,"cMask":["ball"],"trait":"goalPost"},{"v0":32,"v1":33,"curve":0,"vis":false,"color":"FFCCCC","bCoef":1,"cMask":["ball"],"trait":"goalPost"},{"v0":34,"v1":35,"curve":0,"vis":true,"color":"000000","bCoef":0.1,"cMask":["red"],"cGroup":["blueKO"],"trait":"goalPost"},{"v0":30,"v1":36,"vis":true,"color":"ffffff","bCoef":1,"trait":"goalNet","x":370},{"v0":26,"v1":37,"vis":true,"color":"ffffff","bCoef":1,"cMask":["ball"],"trait":"goalNet","x":-370},{"v0":38,"v1":8,"curve":0,"vis":true,"color":"FFFFFF","bCoef":1,"cMask":["ball"],"trait":"goalNet","x":-370},{"v0":39,"v1":19,"curve":0,"vis":true,"color":"ffffff","bCoef":1,"cMask":["ball"],"trait":"goalNet","x":370},{"v0":28,"v1":29,"curve":0,"vis":true,"color":"ffffff","bCoef":1,"cMask":["ball"],"trait":"goalNet","x":-370},{"v0":40,"v1":41,"curve":0,"vis":true,"color":"ffffff","bCoef":1,"trait":"goalNet","x":370},{"v0":42,"v1":23,"curve":0,"vis":true,"color":"ffffff","bCoef":1,"trait":"goalNet","x":-370},{"v0":43,"v1":44,"curve":0,"vis":true,"color":"ffffff","bCoef":1,"trait":"goalNet","x":370},{"v0":23,"v1":19,"curve":0,"vis":true,"color":"ffffff","bCoef":1.4,"cMask":["ball"],"trait":"goalNet"},{"v0":26,"v1":30,"curve":0,"vis":true,"color":"ffffff","bCoef":1.4,"cMask":["ball"],"trait":"goalNet"},{"v0":3,"v1":45,"curve":1.50571568977,"vis":true,"color":"FFFFFF","bCoef":0.1,"cMask":["wall"],"x":0},{"v0":52,"v1":53,"curve":0,"vis":true,"color":"F0FF0F","bCoef":0.1,"cMask":["red"],"cGroup":["red"],"trait":"goalPost"},{"v0":54,"v1":55,"curve":0,"vis":true,"color":"F0FF0F","bCoef":0.1,"cMask":["blue"],"cGroup":["blue"],"trait":"goalPost"}],"goals":[{"p0":[-369,-146],"p1":[-369,-102],"team":"red","color":"000000","x":-370},{"p0":[370,-110],"p1":[370,-150],"team":"blue","x":370,"color":"000000"},{"p0":[-370,-35],"p1":[-370,35],"team":"red","color":"000000","x":-370},{"p0":[-370,103],"p1":[-370,143],"team":"red","color":"000000","x":-370},{"p0":[370,143],"p1":[370,98],"team":"blue","x":370,"color":"000000"},{"p0":[370,35],"p1":[370,-35],"team":"blue","x":370,"color":"000000"}],"discs":[{"pos":[-370,-105],"color":"ffffff","bCoef":0.5,"trait":"goalPost"},{"pos":[-370,-144],"color":"ffffff","bCoef":0.5,"trait":"goalPost"},{"pos":[370,-105],"color":"ffffff","bCoef":0.5,"trait":"goalPost"},{"pos":[370,-143],"color":"FFFFFF","bCoef":0.5,"trait":"goalPost"},{"pos":[-370,35],"color":"ff0000","bCoef":0.5,"trait":"goalPost"},{"pos":[-370,-35],"color":"ff0000","bCoef":0.5,"trait":"goalPost"},{"pos":[-370,143],"color":"ffffff","bCoef":0.5,"trait":"goalPost"},{"pos":[-370,105],"color":"ffffff","bCoef":0.5,"trait":"goalPost"},{"pos":[370,143],"color":"FFFFFF","bCoef":0.5,"trait":"goalPost"},{"pos":[370,104],"color":"FFFFFF","bCoef":0.5,"trait":"goalPost"},{"pos":[370,41],"color":"0000FF","bCoef":0.5,"trait":"goalPost"},{"pos":[370,-35],"color":"0000FF","bCoef":0.5,"trait":"goalPost"}],"planes":[{"normal":[0,-1],"dist":-170,"bCoef":1,"trait":"ballArea"},{"normal":[0,1],"dist":-170,"bCoef":1,"cMask":["ball"],"trait":"ballArea"},{"normal":[1,0],"dist":-423.311779142,"bCoef":0.1},{"normal":[-1,0],"dist":-423.310955619,"bCoef":0.1},{"normal":[0,-1],"dist":-200,"bCoef":0.1},{"normal":[0,1],"dist":-200,"bCoef":0.1}],"traits":{"ballArea":{"vis":false,"bCoef":1,"cMask":["ball"]},"goalPost":{"radius":8,"invMass":0,"bCoef":0.5},"goalNet":{"vis":true,"bCoef":0.1,"cMask":["ball"]},"kickOffBarrier":{"vis":false,"bCoef":0.1,"cGroup":["redKO","blueKO"],"cMask":["red","blue"]}},"playerPhysics":{"bCoef":0.5,"invMass":0.5,"damping":0.96,"acceleration":0.12,"kickingAcceleration":0.12,"kickingDamping":0.96,"kickStrength":13},"ballPhysics":{"color":"FFFFFF","radius":10}}'; // Insert your map for 1v1 and 2v2 here. To get minimum file size, here are the instructions : 1. Download the map 2. Go to https://cssminifier.com 3. Paste the result


// variables.js
/* OPTIONS */
const afkLimit = 12;
const drawTimeLimit = Infinity;
const maxTeamSize = 2;
let slowMode = 0;

/* PLAYERS */
const Team = { SPECTATORS: 0, RED: 1, BLUE: 2 };
const extendedP = [];
// Player Object ID, AUTH, CONNECTION, AFK STATUS, ACTIVITY, GOALKEEPER, MUTE, LAST_MSG_TIME, MSG_COUNT
const eP = { ID: 0, AUTH: 1, CONN: 2, AFK: 3, ACT: 4, GK: 5, MUTE: 6, LASTMSG: 7, COUNT: 8 };
// Stats: "Auth" : '["0-Games", "1-Wins", "2-Draws", "3-Losses", "4-Winrate", "5-Goals", "6-Assists", "7-GK", "8-CS", "9-CS%", "10- ELO", "11-Role", "12-Nick", "13-Emoji", "14-Color", "15-MSG"]'
const Ss = { GA: 0, WI: 1, DR: 2, LS: 3, WR: 4, GL: 5, AS: 6, GK: 7, CS: 8, CP: 9, ELO: 10, RL: 11, NK: 12, EMOJI: 13, COLOR: 14, MSG: 15};
let players;
let teamR;
let teamB;
let teamS;

/* GAME */

let lastTeamTouched; // helps track Goals
let lastPlayersTouched; // helps track Goals
let countAFK = false; // Helps track Activity
let activePlay = false; // helps track ball Posession
let goldenGoal = false;
const SMSet = new Set(); // Slowmode
let banList = []; // helps track bans

/* STATS */

let game;
let GKList = ["", ""];
let Rposs = 0;
let Bposs = 0;
const point = [{"x": 0, "y": 0}, {"x": 0, "y": 0}]; // created to get ball speed
let ballSpeed;
let lastWinner = Team.SPECTATORS;
let streak = 0;
let allBlues = []; // This is to count the players who should be counted for the stats. This includes players who left after the game has started, doesn't include those who came too late or ...
let allReds = []; // ... those who came in a very unequal game.

/* BALANCE & CHOOSE */

let inChooseMode = false; // This variable enables to distinguish the 2 phases of playing and choosing which should be dealt with very differently
let redCaptainChoice = "";
let blueCaptainChoice = "";
const chooseTime = 20;
let timeOutCap;

/* AUXILIARY */

let checkTimeVariable = false; // This is created so the chat doesn't get spammed when a game is ending via timeLimit
let statNumber = 0; // This allows the room to be given stat information every X minutes
let endGameVariable = false; // This variable with the one below helps distinguish the cases where games are stopped because they have finished to the ones where games are stopped due to player movements or resetting teams
let resettingTeams = false;
let capLeft = false;
const statInterval = 6;

loadMap(aloneMap, 0, 0);


// objects.js
/* OBJECTS */

function Goal(time, team, striker, assist) {
	this.time = time;
	this.team = team;
	this.striker = striker;
	this.assist = assist;
}

function Game(date, scores, goals) {
	this.date = date;
	this.scores = scores;
	this.goals = goals;
}


// auxiliary_functions.js
/* FUNCTIONS */

/* AUXILIARY FUNCTIONS */



/**
 * The getRandomInt function generates a random integer between 0 and the specified maximum value.
 * @param max - The maximum value that the random integer can be.
 * @returns a random integer between 0 (inclusive) and the specified maximum value (exclusive).
 */
function getRandomInt(max) {
	return Math.floor(Math.random() * Math.floor(max));
}


/**
 * The getTime function returns the current time of the game in the format [MM:SS].
 * @param scores - The parameter "scores" is an object that contains information about the game,
 * including the current time.
 * @returns a string representing the current time of the game in the format "[MM:SS]".
 */
function getTime(scores) {
	return "[" + Math.floor(Math.floor(scores.time/60)/10).toString() + Math.floor(Math.floor(scores.time/60)%10).toString() + ":" + Math.floor(Math.floor(scores.time - (Math.floor(scores.time/60) * 60))/10).toString() + Math.floor(Math.floor(scores.time - (Math.floor(scores.time/60) * 60))%10).toString() + "]"
}


/**
 * The function calculates the distance between two points in a two-dimensional space.
 * @param p1 - The parameter p1 represents the first point, which is an object with properties x and y
 * representing the coordinates of the point.
 * @param p2 - The above code defines a function called `pointDistance` that calculates the distance
 * between two points in a two-dimensional space.
 * @returns the distance between two points, calculated using the Pythagorean theorem.
 */
function pointDistance(p1, p2) {
	var d1 = p1.x - p2.x;
	var d2 = p1.y - p2.y;
	return Math.sqrt(d1 * d1 + d2 * d2);
}


/* BUTTONS */

/**
 * Top button that choose the player that is first in the queue.
 * @returns nothing if the condition `teamS.length == 0` is true. Otherwise, it is returning the result
 * of the team assignment operations.
 */
function topBtn() {
	if (teamS.length == 0) {
		return;
	}
	else {
		if (teamR.length == teamB.length) {
			if (teamS.length > 1) {
				room.setPlayerTeam(teamS[0].id, Team.RED);
				room.setPlayerTeam(teamS[1].id, Team.BLUE);
			}
			return;
		}
		else if (teamR.length < teamB.length) {
			room.setPlayerTeam(teamS[0].id, Team.RED);
		}
		else {
			room.setPlayerTeam(teamS[0].id, Team.BLUE);
		}
	}
}

/**
 * The function randomly assigns players to the red or blue team based on the current team sizes.
 * @returns nothing if the condition `teamS.length == 0` is true. Otherwise, it returns undefined.
 */
function randomBtn() {
	if (teamS.length == 0) {
		return;
	}
	else {
		if (teamR.length == teamB.length) {
			if (teamS.length > 1) {
				var r = getRandomInt(teamS.length);
				room.setPlayerTeam(teamS[r].id, Team.RED);
				teamS = teamS.filter((spec) => spec.id != teamS[r].id);
				room.setPlayerTeam(teamS[getRandomInt(teamS.length)].id, Team.BLUE);
			}
			return;
		}
		else if (teamR.length < teamB.length) {
			room.setPlayerTeam(teamS[getRandomInt(teamS.length)].id, Team.RED);
		}
		else {
			room.setPlayerTeam(teamS[getRandomInt(teamS.length)].id, Team.BLUE);
		}
	}
}

/**
 * The function "blueToSpecBtn" resets the teams in a game by moving all players from the blue team to
 * the spectators team.
 */
function blueToSpecBtn() {
	resettingTeams = true;
	setTimeout(() => { resettingTeams = false; }, 100);
	for (var i = 0; i < teamB.length; i++) {
		room.setPlayerTeam(teamB[teamB.length - 1 - i].id, Team.SPECTATORS);
	}
}

/**
 * The function "redToSpecBtn" resets the teams of all players in the "teamR" array to the spectator
 * team.
 */
function redToSpecBtn() {
	resettingTeams = true;
	setTimeout(() => { resettingTeams = false; }, 100);
	for (var i = 0; i < teamR.length; i++) {
		room.setPlayerTeam(teamR[teamR.length - 1 - i].id, Team.SPECTATORS);
	}
}

/**
 * The function `resetBtn` resets the teams in a game by moving players to the spectators team.
 */
function resetBtn() {
	resettingTeams = true;
	setTimeout(() => { resettingTeams = false; }, 100);
	if (teamR.length <= teamB.length) {
		for (var i = 0; i < teamR.length; i++) {
			room.setPlayerTeam(teamB[teamB.length - 1 - i].id, Team.SPECTATORS);
			room.setPlayerTeam(teamR[teamR.length - 1 - i].id, Team.SPECTATORS);
		}
		for (var i = teamR.length; i < teamB.length; i++) {
			room.setPlayerTeam(teamB[teamB.length - 1 - i].id, Team.SPECTATORS);
		}
	}
	else {
		for (var i = 0; i < teamB.length; i++) {
			room.setPlayerTeam(teamB[teamB.length - 1 - i].id, Team.SPECTATORS);
			room.setPlayerTeam(teamR[teamR.length - 1 - i].id, Team.SPECTATORS);
		}
		for (var i = teamB.length; i < teamR.length; i++) {
			room.setPlayerTeam(teamR[teamR.length - 1 - i].id, Team.SPECTATORS);
		}
	}
}


/**
 * The function changes the team of all players in teamB to the red team.
 */
function blueToRedBtn() {
	resettingTeams = true;
	setTimeout(() => { resettingTeams = false; }, 100);
	for (var i = 0; i < teamB.length; i++) {
		room.setPlayerTeam(teamB[i].id, Team.RED);
	}
}

// time.js
/**
 * The function checks the time remaining in a game and performs certain actions based on the time and
 * game scores.
 */
function checkTime() {
	const scores = room.getScores();
	game.scores = scores;
	if (Math.abs(scores.time - scores.timeLimit) <= 0.01 && scores.timeLimit != 0) {
		if (scores.red != scores.blue) {
			if (checkTimeVariable == false) {
				checkTimeVariable = true;
				setTimeout(() => { checkTimeVariable = false; }, 3000);
				scores.red > scores.blue ? endGame(Team.RED) : endGame(Team.BLUE);
				setTimeout(() => { room.stopGame(); }, 2000);
			}
			return;
		}
		goldenGoal = true;
		room.sendAnnouncement("Gol gana! El que pierde es fan de vox.", null, 0x4ffaff, "bold", 1);
	}
	if (Math.abs(scores.time - drawTimeLimit * 60) <= 0.01 && players.length > 2) {
		if (checkTimeVariable == false) {
			checkTimeVariable = true;
			setTimeout(() => { checkTimeVariable = false; }, 10);
			endGame(Team.SPECTATORS);
			room.stopGame();
			goldenGoal = false;
		}
	}
}


// start_game.js
/**
 * The function "endGame" handles the end of a game by updating scores, determining the winner,
 * announcing the result, and updating statistics.
 * @param winner - The `winner` parameter in the `endGame` function represents the team that won the
 * game. It can have one of the following values: Team.BLUE (blue team won), Team.RED (red team won).
 */
function endGame(winner) { // handles the end of a game
	players.length >= 2 * maxTeamSize - 1 ? activateChooseMode() : null;
	const scores = room.getScores();
	game.scores = scores;
	Rposs = Rposs/(Rposs+Bposs);
	Bposs = 1 - Rposs;
	lastWinner = winner;
	endGameVariable = true;
	if (winner == Team.RED) {
		streak++;
		room.sendAnnouncement(Bot + " El equipo rojo ganó " + scores.red + "-" + scores.blue + " ! Victorias consecutivas : " + streak + " ", null, 0x4ffaff, "bold", 2);
	}
	else if (winner == Team.BLUE) {
		streak = 1;
		room.sendAnnouncement(Bot + " El equipo azul ganó " + scores.blue + "-" + scores.red + " ! Victorias consecutivas : " + streak + " ", null, 0x4ffaff, "bold", 2);
	}
	else {
		streak = 0;
		room.sendAnnouncement(Bot +" Límite de empate, terminado! ", null, 0x4ffaff, "bold", 2);
    }
    scores.red == 0 ? (scores.blue == 0 ? room.sendAnnouncement(Bot + GKList[0].name + " y " + GKList[1].name + " mantuvieron la porteria a 0 ! ") : room.sendAnnouncement(Bot + GKList[1].name + " mantuvo la porteria a 0 ! ", null, 0x4ffaff, "bold", 2)) : scores.blue == 0 ? room.sendAnnouncement(Bot + GKList[0].name + " mantuvo la porteria a 0 ! ", null, 0x4ffaff, "bold", 2) : null;
	updateStats();
}

/**
 * The function `quickRestart` stops the current game in a room and then starts a new game after a
 * 2-second delay.
 */
function quickRestart() {
	room.stopGame();
	setTimeout(() => { room.startGame(); }, 2000);
}


/**
 * The function resumeGame() starts a game after a delay of 2 seconds and then immediately unpauses the
 * game after a delay of 1 second.
 */
function resumeGame() {
	setTimeout(() => { room.startGame(); }, 2000);
	setTimeout(() => { room.pauseGame(false); }, 1000);
}


// game_setup.js
/**
 * The function activates the choose mode and sends an announcement message.
 */
function activateChooseMode() {
	inChooseMode = true;
	slowMode = 2;
	room.sendAnnouncement(Bot + "Reconfigurando juego!", null, 0x4ffaff, "bold", 1);
}

/**
 * The function "deactivateChooseMode" is used to deactivate the choose mode and reset the choice variables.
 */
function deactivateChooseMode() {
	inChooseMode = false;
	clearTimeout(timeOutCap);
	if (slowMode != 0) {
		slowMode = 0;
		room.sendAnnouncement(Bot + "Jueguen pues", null, 0x4ffaff, "bold", 1);
	}
	redCaptainChoice = "";
	blueCaptainChoice = "";
}

/**
 * The function `loadMap` sets the custom stadium, score limit, and time limit for a game room based on
 * the provided parameters.
 * @param map - The "map" parameter is used to specify the stadium or map that will be loaded in the
 * game. It can be a custom stadium or one of the predefined stadiums such as "Classic" or "Big".
 * @param scoreLim - The `scoreLim` parameter is used to set the score limit for the game. It
 * determines how many points a team or player needs to reach in order to win the game.
 * @param timeLim - The `timeLim` parameter in the `loadMap` function represents the time limit for the
 * game. It specifies the maximum duration for a game session.
 */
function loadMap(map, scoreLim, timeLim) {
	if (map == aloneMap) {
		room.setCustomStadium(aloneMap);
	}
	else if (map == classicMap) {
		(classicMap != '') ? room.setCustomStadium(classicMap) : room.setDefaultStadium("Classic");
	}
	else if (map == bigMap) {
		(bigMap != '.') ? room.setCustomStadium(bigMap) : room.setDefaultStadium("Big");
	}
	else {
		room.setCustomStadium(map);
	}
	room.setScoreLimit(scoreLim);
	room.setTimeLimit(timeLim);
}

/* PLAYER FUNCTIONS */

/**
 * The function updates the players' list and separates them into different teams.
 */
function updateTeams() {
	players = room.getPlayerList().filter((player) => player.id != 0 && !getAFK(player));
	teamR = players.filter(p => p.team === Team.RED);
	teamB = players.filter(p => p.team === Team.BLUE);
	teamS = players.filter(p => p.team === Team.SPECTATORS);
}


/**
 * The function handles inactivity by incrementing the activity count for each player and kicking them
 * if they exceed the afkLimit.
 */
function handleInactivity() {
	if (countAFK && (teamR.length + teamB.length) > 1) {
		for (var i = 0; i < teamR.length ; i++) {
			setActivity(teamR[i], getActivity(teamR[i]) + 1);
		}
		for (var i = 0; i < teamB.length ; i++) {
			setActivity(teamB[i], getActivity(teamB[i]) + 1);
		}
	}
	for (var i = 0; i < extendedP.length ; i++) {
		if (extendedP[i][eP.ACT] == 60 * (2/3 * afkLimit)) {
			room.sendAnnouncement(Bot + room.getPlayer(extendedP[i][eP.ID]).name + ", si no te mueves o envías un mensaje dentro de los siguientes " + Math.floor(afkLimit / 3) + " segundos, seras expulsado!", extendedP[i][eP.ID], 0x4ffaff, "bold", 2);
		}
		if (extendedP[i][eP.ACT] >= 60 * afkLimit) {
			extendedP[i][eP.ACT] = 0;
            if (room.getScores().time <= afkLimit - 0.5) {
				setTimeout(() => { !inChooseMode ? quickRestart() : room.stopGame(); }, 10);
			}
			room.kickPlayer(extendedP[i][eP.ID], "AFK", false);
		}
	}
}


// getAuth.js
/**
 * The function "getAuth" returns the authentication value for a given player.
 * @param player - The "player" parameter is an object that represents a player.
 * @returns the value of the `eP.AUTH` property of the first element in the `extendedP` array that has
 * a matching `player.id` value. If no matching element is found, it returns `null`.
 */
function getAuth(player) {
	return extendedP.filter((a) => a[0] == player.id) != null ? extendedP.filter((a) => a[0] == player.id)[0][eP.AUTH] : null;
}


// player_control.js
/**
 * The function "getAFK" returns the AFK status of a player.
 * @param player - The parameter "player" is an object that represents a player in a game.
 * @returns the AFK status of a player. If the player is found in the extendedP array, it will return
 * their AFK status. If the player is not found, it will return null.
 */
function getAFK(player) {
	return extendedP.filter((a) => a[0] == player.id) != null ? extendedP.filter((a) => a[0] == player.id)[0][eP.AFK] : null;
}

/**
 * The function sets the AFK (Away From Keyboard) status of a player.
 * @param player - The "player" parameter is an object that represents a player in a game. It likely
 * has properties such as "id" to identify the player and "AFK" to indicate whether the player is away
 * from the keyboard (AFK) or not.
 * @param value - The "value" parameter in the "setAFK" function is used to set the AFK (Away From
 * Keyboard) status of a player. It can be either true or false, indicating whether the player is AFK
 * or not.
 */
function setAFK(player, value) {
	extendedP.filter((a) => a[0] == player.id).forEach((player) => player[eP.AFK] = value);
}

function getActivity(player) {
	return extendedP.filter((a) => a[0] == player.id) != null ? extendedP.filter((a) => a[0] == player.id)[0][eP.ACT] : null;
}

function setActivity(player, value) {
	extendedP.filter((a) => a[0] == player.id).forEach((player) => player[eP.ACT] = value);
}

function getGK(player) {
	return extendedP.filter((a) => a[0] == player.id) != null ? extendedP.filter((a) => a[0] == player.id)[0][eP.GK] : null;
}

function setGK(player, value) {
	extendedP.filter((a) => a[0] == player.id).forEach((player) => player[eP.GK] = value);
}

function getMute(player) {
	return extendedP.filter((a) => a[0] == player.id) != null ? extendedP.filter((a) => a[0] == player.id)[0][eP.MUTE] : null;
}

function setMute(player, value) {
	extendedP.filter((a) => a[0] == player.id).forEach((player) => player[eP.MUTE] = value);
}


// balance_choose.js
/* BALANCE & CHOOSE FUNCTIONS */

/**
 * The function updates the role of a player in a game and performs various actions related to team
 * balancing and map loading.
 */
function updateRoleOnPlayerIn() {
	updateTeams();
	if (inChooseMode) {
		if (players.length == 6) {
			loadMap(bigMap, scoreLimitBig, timeLimitBig);
		}
		getSpecList(teamR.length <= teamB.length ? teamR[0] : teamB[0]);
	}
	balanceTeams();
}

/**
 * The function `updateRoleOnPlayerOut` is responsible for updating the roles and teams of players in a
 * game, handling situations such as players leaving or joining teams, balancing teams, and ending the
 * game if there is an abandonment.
 */
function updateRoleOnPlayerOut() {
    updateTeams();
	if (room.getScores() != null) {
		var scores = room.getScores();
		if (players.length >= 2 * maxTeamSize && scores.time >= (5/6) * game.scores.timeLimit && teamR.length != teamB.length) {
			if (teamR.length < teamB.length) {
				if (scores.blue - scores.red == 2) {
					endGame(Team.BLUE);
					room.sendAnnouncement(Bot + "Abandono detectado. Juego terminado", null, 0x4ffaff, "bold", 2);
					setTimeout(() => { room.stopGame(); }, 100);
					return;
				}
			}
			else {
				if (scores.red - scores.blue == 2) {
					endGame(Team.RED);
					room.sendAnnouncement("Abandono detectado. Juego terminado", null, 0x4ffaff, "bold", 2);
					setTimeout(() => { room.stopGame(); }, 100);
					return;
				}
			}
		}
	}
	if (inChooseMode) {
		if (players.length == 5) {
			loadMap(classicMap, scoreLimitClassic, timeLimitClassic);
		}
		if (teamR.length == 0 || teamB.length == 0) {
		if (teamR.length === 0) {
    room.setPlayerTeam(teamS[0].id, Team.RED);
} else {
    room.setPlayerTeam(teamS[0].id, Team.BLUE);
}
			return;
		}
		if (Math.abs(teamR.length - teamB.length) == teamS.length) {
			room.sendAnnouncement("No hay alternativa, déjame manejar esta situación ...", null, 0x4ffaff, "bold", 2);
			deactivateChooseMode();
			resumeGame();
			var b = teamS.length;
			if (teamR.length > teamB.length) {
				for (var i = 0 ; i < b ; i++) {
					setTimeout(() => { room.setPlayerTeam(teamS[0].id, Team.BLUE); }, 5*i);
				}
			}
			else {
				for (var i = 0 ; i < b ; i++) {
					setTimeout(() => { room.setPlayerTeam(teamS[0].id, Team.RED); }, 5*i);
				}
			}
			return;
		}
		if (streak == 0 && room.getScores() == null) {
			if (Math.abs(teamR.length - teamB.length) == 2) { // if someone left a team has 2 more players than the other one, put the last chosen guy back in his place so it's fair
				room.sendAnnouncement(Bot + " Equilibrando equipos... ", null, 0x4ffaff, "bold", 1);
				teamR.length > teamB.length ? room.setPlayerTeam(teamR[teamR.length - 1].id, Team.SPECTATORS) : room.setPlayerTeam(teamB[teamB.length - 1].id, Team.SPECTATORS);
			}
		}
		if (teamR.length == teamB.length && teamS.length < 2) {
			deactivateChooseMode();
			resumeGame();
			return;
		}
		capLeft ? choosePlayer() : getSpecList(teamR.length <= teamB.length ? teamR[0] : teamB[0]);
	}
	balanceTeams();
}

/**
 * The function "balanceTeams" is used to balance the teams in a game based on the number of players
 * and the current team sizes.
 */
function balanceTeams() {
	if (!inChooseMode) {
		if (players.length == 1 && teamR.length == 0) {
            quickRestart();
            loadMap(aloneMap, 0, 0);
			room.setPlayerTeam(players[0].id, Team.RED);
		}
		else if (Math.abs(teamR.length - teamB.length) == teamS.length && teamS.length > 0) {
			const n = Math.abs(teamR.length - teamB.length);
			if (players.length == 2) {
				quickRestart();
				loadMap(classicMap, scoreLimitClassic, timeLimitClassic);
			}
			if (teamR.length > teamB.length) {
				for (var i = 0 ; i < n ; i++) {
					room.setPlayerTeam(teamS[i].id, Team.BLUE);
				}
			}
			else {
				for (var i = 0 ; i < n ; i++) {
					room.setPlayerTeam(teamS[i].id, Team.RED);
				}
			}
		}
		else if (Math.abs(teamR.length - teamB.length) > teamS.length) {
			const n = Math.abs(teamR.length - teamB.length);
			if (players.length == 1) {
				quickRestart();
				loadMap(aloneMap, 0, 0);
				room.setPlayerTeam(players[0].id, Team.RED);
				return;
			}
			else if (players.length == 5) {
				quickRestart();
				loadMap(classicMap, scoreLimitClassic, timeLimitClassic);
			}
			if (players.length == maxTeamSize * 2 - 1) {
				allReds = [];
				allBlues = [];
			}
			if (teamR.length > teamB.length) {
				for (var i = 0 ; i < n ; i++) {
					room.setPlayerTeam(teamR[teamR.length - 1 - i].id, Team.SPECTATORS);
				}
			}
			else {
				for (var i = 0 ; i < n ; i++) {
					room.setPlayerTeam(teamB[teamB.length - 1 - i].id, Team.SPECTATORS);
				}
			}
		}
		else if (Math.abs(teamR.length - teamB.length) < teamS.length && teamR.length != teamB.length) {
			room.pauseGame(true);
			activateChooseMode();
			choosePlayer();
		}
		else if (teamS.length >= 2 && teamR.length == teamB.length && teamR.length < maxTeamSize) {
			if (teamR.length == 2) {
				quickRestart();
				loadMap(bigMap, scoreLimitBig, timeLimitBig);
			}
			topBtn();
		}
	}
}

/**
 * The function "choosePlayer" is used to select a player from a list based on their ID, top position,
 * random selection, or bottom position.
 */
function choosePlayer() {
	clearTimeout(timeOutCap);
	if (teamR.length <= teamB.length && teamR.length != 0) {
		room.sendAnnouncement(Bot +"Para elegir un jugador, ingrese su número en la lista dada o use 'top', 'random' o 'bottom'.", teamR[0].id, 0x4ffaff, "bold", 2);
		timeOutCap = setTimeout(function (player) { room.sendAnnouncement("Date prisa @" + player.name + ", solo quedan " + Number.parseInt(chooseTime / 2) + " segundos para elegir !", player.id); timeOutCap = setTimeout(function (player) { room.kickPlayer(player.id, "¡No elegiste a tiempo!", false); }, chooseTime * 500, teamR[0]); }, chooseTime * 1000, teamR[0], "bold", 1

		);
	}
	else if (teamB.length < teamR.length && teamB.length != 0) {
		room.sendAnnouncement(Bot + " Para elegir un jugador, ingrese su número en la lista dada o use 'top', 'random' o 'bottom'.", teamB[0].id, 0x4ffaff, "bold", 2);
		timeOutCap = setTimeout(function (player) { room.sendAnnouncement(Bot + "Apura coño @" + player.name + ", solo quedan " + Number.parseInt(chooseTime / 2) + " segundos para elegir !", player.id, 0x4ffaff, "bold", 2); timeOutCap = setTimeout(function (player) { room.kickPlayer(player.id, "¡No elegiste a tiempo!", false); }, chooseTime * 500, teamB[0]); }, chooseTime * 1000, teamB[0]);
	}
	if (teamR.length != 0 && teamB.length != 0) getSpecList(teamR.length <= teamB.length ? teamR[0] : teamB[0]);
}


/**
 * The function "getSpecList" sends a list of players in a team to a specific player.
 * @param player - The parameter "player" represents the player for whom the special list is being
 * generated.
 */
function getSpecList(player) {
	var cstm = " Jugadores : ";
	for (var i = 0 ; i < teamS.length ; i++) {
		if (140 - cstm.length < (teamS[i].name + "[" + (i+1) + "], ").length) {
			room.sendAnnouncement(cstm, player.id, 0x4ffaff, "bold", 2);
			cstm = "... ";
		}
		cstm += teamS[i].name + "[" + (i+1) + "], ";
	}
	cstm = cstm.substring(0,cstm.length - 2);
	cstm += ".";
	room.sendAnnouncement(cstm, player.id, 0x4ffaff, "bold", 2);
}


// stats.js
/* STATS FUNCTIONS */

/**
 * The function getLastTouchOfTheBall checks which player from which team touched the ball last.
 */
function getLastTouchOfTheBall() {
	const ballPosition = room.getBallPosition();
	updateTeams();
	for (var i = 0; i < players.length; i++) {
		if (players[i].position != null) {
			var distanceToBall = pointDistance(players[i].position, ballPosition);
			if (distanceToBall < triggerDistance) {
				!activePlay ? activePlay = true : null;
				if (lastTeamTouched == players[i].team && lastPlayersTouched[0] != null && lastPlayersTouched[0].id != players[i].id) {
					lastPlayersTouched[1] = lastPlayersTouched[0];
					lastPlayersTouched[0] = players[i];
				}
				lastTeamTouched = players[i].team;
			}
		}
	}
}

/**
 * The function `getStats()` updates the possession, ball speed, and goalkeeper statistics for each
 * team during an active play.
 */
function getStats() {
	if (activePlay) {
		updateTeams();
		lastTeamTouched == Team.RED ? Rposs++ : Bposs++;
		var ballPosition = room.getBallPosition();
		point[1] = point[0];
		point[0] = ballPosition;
		ballSpeed = (pointDistance(point[0], point[1]) * 60 * 60 * 60)/15000;
		var k = [-1, Infinity];
		for (var i = 0; i < teamR.length; i++) {
			if (teamR[i].position.x < k[1]) {
				k[0] = teamR[i];
				k[1] = teamR[i].position.x;
			}
		}
		k[0] != -1 ? setGK(k[0], getGK(k[0]) + 1) : null;
		k = [-1, -Infinity];
		for (var i = 0; i < teamB.length; i++) {
			if (teamB[i].position.x > k[1]) {
				k[0] = teamB[i];
				k[1] = teamB[i].position.x;
			}
		}
		k[0] != -1 ? setGK(k[0], getGK(k[0]) + 1) : null;
		findGK();
	}
}



/**
 * The function "updateStats" updates the statistics of players in a game, including games played,
 * wins, losses, win rate, goals, assists, clean sheets, and Elo rating.
 */
function updateStats() {
	// Checks when game is over
	if (players.length >= 2 * maxTeamSize && (game.scores.time >= (5 / 6) * game.scores.timeLimit || game.scores.red == game.scores.scoreLimit || game.scores.blue == game.scores.scoreLimit) && allReds.length >= maxTeamSize && allBlues.length >= maxTeamSize) {
		var stats;
		// for all RED players
		for (var i = 0; i < allReds.length; i++) {
			// Get all the items in the JSON file
			// stats: [0] Games played, [1] Wins, [2] Losses, [3] Draws, [4] Winrate, [5] Goals, [6] Assists, [7] Clean sheets, [8] Saves, [9] Save rate, [10] Elo rating, [11] Player type, [12] Player name
			localStorage.getItem(getAuth(allReds[i])) ? stats = JSON.parse(localStorage.getItem(getAuth(allReds[i]))) : stats = [0, 0, 0, 0, "0.00", 0, 0, 0, 0, "0.00", 0, "player", allReds[i].name, "", 0x000000, ""];
			// +1 in Games played
			stats[Ss.GA]++;
			// Which team won?
			lastWinner == Team.RED ? stats[Ss.WI]++ : lastWinner == Team.BLUE ? stats[Ss.LS]++ : stats[Ss.DR]++;
			// Winrrate recalculation
			stats[Ss.WR] = (100 * stats[Ss.WI] / stats[Ss.GA]).toPrecision(3);
			// Saves into Localstore JSON
			localStorage.setItem(getAuth(allReds[i]), JSON.stringify(stats));
		}
		// The same for Blue TEAM
		for (var i = 0; i < allBlues.length; i++) {
			localStorage.getItem(getAuth(allBlues[i])) ? stats = JSON.parse(localStorage.getItem(getAuth(allBlues[i]))) : stats = [0, 0, 0, 0, "0.00", 0, 0, 0, 0, "0.00", 0, "player", allBlues[i].name, "", 0x000000, ""];
			stats[Ss.GA]++;
			lastWinner == Team.BLUE ? stats[Ss.WI]++ : lastWinner == Team.RED ? stats[Ss.LS]++ : stats[Ss.DR]++;
			stats[Ss.WR] = (100 * stats[Ss.WI] / stats[Ss.GA]).toPrecision(3);
			localStorage.setItem(getAuth(allBlues[i]), JSON.stringify(stats));
		}
        // Goals recalculation
		for (var i = 0; i < game.goals.length; i++) {
			if (game.goals[i].striker != null) {
				if ((allBlues.concat(allReds)).findIndex((player) => player.id == game.goals[i].striker.id) != -1) {
					stats = JSON.parse(localStorage.getItem(getAuth(game.goals[i].striker)));
					stats[Ss.GL]++;
					localStorage.setItem(getAuth(game.goals[i].striker), JSON.stringify(stats));
				}
			}
            // Assists recalculation
			if (game.goals[i].assist != null) {
				if ((allBlues.concat(allReds)).findIndex((player) => player.name == game.goals[i].assist.name) != -1) {
					stats = JSON.parse(localStorage.getItem(getAuth(game.goals[i].assist)));
					stats[Ss.AS]++;
					localStorage.setItem(getAuth(game.goals[i].assist), JSON.stringify(stats));
				}
			}
		}
        // GK recalculation
		if (allReds.findIndex((player) => player.id == GKList[0].id) != -1) {
			stats = JSON.parse(localStorage.getItem(getAuth(GKList[0])));
			stats[Ss.GK]++;
			game.scores.blue == 0 ? stats[Ss.CS]++ : null;
			stats[Ss.CP] = (100 * stats[Ss.CS] / stats[Ss.GK]).toPrecision(3);
			localStorage.setItem(getAuth(GKList[0]), JSON.stringify(stats));
		}
		if (allBlues.findIndex((player) => player.id == GKList[1].id) != -1) {
			stats = JSON.parse(localStorage.getItem(getAuth(GKList[1])));
			stats[Ss.GK]++;
			game.scores.red == 0 ? stats[Ss.CS]++ : null;
			stats[Ss.CP] = (100 * stats[Ss.CS] / stats[Ss.GK]).toPrecision(3);
			localStorage.setItem(getAuth(GKList[1]), JSON.stringify(stats));
		}
        // Elo recalculation for RED
        for (var i = 0; i < allReds.length; i++) {
			localStorage.getItem(getAuth(allReds[i])) ? stats = JSON.parse(localStorage.getItem(getAuth(allReds[i]))) : stats = [0, 0, 0, 0, "0.00", 0, 0, 0, 0, "0.00", 0, "player", allReds[i].name, "", 0x000000, ""];
            stats[Ss.ELO] = (1 + (stats[Ss.WI]*3)+(stats[Ss.LS]*-1)+(stats[Ss.GL]*3)+(stats[Ss.AS]*2)+(stats[Ss.CS]*4));
			localStorage.setItem(getAuth(allReds[i]), JSON.stringify(stats));
		}
		// Elo recalculation for BLUE
		for (var i = 0; i < allBlues.length; i++) {
			localStorage.getItem(getAuth(allBlues[i])) ? stats = JSON.parse(localStorage.getItem(getAuth(allBlues[i]))) : stats = [0, 0, 0, 0, "0.00", 0, 0, 0, 0, "0.00", 0, "player", allBlues[i].name, "", 0x000000, ""];
            stats[Ss.ELO] = (1 + (stats[Ss.WI]*3)+(stats[Ss.LS]*-1)+(stats[Ss.GL]*3)+(stats[Ss.AS]*2)+(stats[Ss.CS]*4));
			localStorage.setItem(getAuth(allBlues[i]), JSON.stringify(stats));
		}
	}
}


// Function to look for the GK :/
function findGK() {
	var tab = [[-1,""], [-1,""]];
	for (var i = 0; i < extendedP.length ; i++) {
		if (room.getPlayer(extendedP[i][eP.ID]) != null && room.getPlayer(extendedP[i][eP.ID]).team == Team.RED) {
			if (tab[0][0] < extendedP[i][eP.GK]) {
				tab[0][0] = extendedP[i][eP.GK];
				tab[0][1] = room.getPlayer(extendedP[i][eP.ID]);
			}
		}
		else if (room.getPlayer(extendedP[i][eP.ID]) != null && room.getPlayer(extendedP[i][eP.ID]).team == Team.BLUE) {
			if (tab[1][0] < extendedP[i][eP.GK]) {
				tab[1][0] = extendedP[i][eP.GK];
				tab[1][1] = room.getPlayer(extendedP[i][eP.ID]);
			}
		}
	}
	GKList = [tab[0][1], tab[1][1]];
}

// onPlayerJoin.js
/* EVENTS */

/* PLAYER MOVEMENT */

// Function that is triggered when a player joins
room.onPlayerJoin = function(player) {

	console.log(player.name + " : " + player.conn);
	extendedP.push([player.id, player.auth, player.conn, false, 0, 0, false, 0, 0]);

	updateRoleOnPlayerIn();

		
	// Stats: "Auth" : '["0-Games", "1-Wins", "2-Draws", "3-Losses", "4-Winrate", "5-Goals", "6-Assists", "7-GK", "8-CS", "9-CS%", "10- ELO", "11-Role", "12-Nick", "13-Emoji", "14-Color", "15-MSG"]'
	localStorage.getItem(getAuth(player)) ? stats = JSON.parse(localStorage.getItem(getAuth(player))) : stats = [0, 0, 0, 0, "0.00", 0, 0, 0, 0, "0.00", 0, "player", player.name, "", "", ""];

	{
		room.sendAnnouncement(Bot + "¡Bienvenido, pon !dc para entrar al Discord del server y !help para ver todos los comandos!", player.id, 0x6FE35D, "bold", 1);
	
	}
}


// onPlayerTeamChange.js
// Function that is triggered when a player change teams
room.onPlayerTeamChange = function(changedPlayer, byPlayer) {
	if (changedPlayer.id == 0) {
		room.setPlayerTeam(0, Team.SPECTATORS);
		return;
	}
	if (getAFK(changedPlayer) && changedPlayer.team != Team.SPECTATORS) {
		room.setPlayerTeam(changedPlayer.id, Team.SPECTATORS);
		room.sendAnnouncement(Bot + changedPlayer.name + " Está dormido, dejalo!", null, 0xA1CDFF, "bold", 1);
		return;
	}
	updateTeams();
	if (room.getScores() != null) {
		var scores = room.getScores();
		if (changedPlayer.team != Team.SPECTATORS && scores.time <= (3/4) * scores.timeLimit  && Math.abs(scores.blue - scores.red) < 2) {
			(changedPlayer.team == Team.RED) ? allReds.push(changedPlayer) : allBlues.push(changedPlayer);
		}
	}
	if (changedPlayer.team == Team.SPECTATORS) {
		setActivity(changedPlayer, 0);
	}
	if (inChooseMode && resettingTeams == false && byPlayer.id == 0) {
		if (Math.abs(teamR.length - teamB.length) == teamS.length) {
			deactivateChooseMode();
			resumeGame();
			var b = teamS.length;
			if (teamR.length > teamB.length) {
				for (var i = 0 ; i < b ; i++) {
					setTimeout(() => { room.setPlayerTeam(teamS[0].id, Team.BLUE); }, 200*i);
				}
			}
			else {
				for (var i = 0 ; i < b ; i++) {
					setTimeout(() => { room.setPlayerTeam(teamS[0].id, Team.RED); }, 200*i);
				}
			}
			return;
		}
		else if ((teamR.length == maxTeamSize && teamB.length == maxTeamSize) || (teamR.length == teamB.length && teamS.length < 2)) {
			deactivateChooseMode();
			resumeGame();
		}
		else if (teamR.length <= teamB.length && redCaptainChoice != "") { // choice remembered
			redCaptainChoice == "top" ? room.setPlayerTeam(teamS[0].id, Team.RED) : redCaptainChoice == "random" ? room.setPlayerTeam(teamS[getRandomInt(teamS.length)].id, Team.RED) : room.setPlayerTeam(teamS[teamS.length - 1].id, Team.RED);
			return;
		}
		else if (teamB.length < teamR.length && blueCaptainChoice != "") {
			blueCaptainChoice == "top" ? room.setPlayerTeam(teamS[0].id, Team.BLUE) : blueCaptainChoice == "random" ? room.setPlayerTeam(teamS[getRandomInt(teamS.length)].id, Team.BLUE) : room.setPlayerTeam(teamS[teamS.length - 1].id, Team.BLUE);
			return;
		}
		else {
			choosePlayer();
		}
	}
}


// onPlayerLeave.js
// Function that is triggered when a player leaves
room.onPlayerLeave = function(player) {
	if (teamR.findIndex((red) => red.id == player.id) == 0 && inChooseMode && teamR.length <= teamB.length) {
		choosePlayer();
		capLeft = true; setTimeout(() => { capLeft = false; }, 10);
	}
	if (teamB.findIndex((blue) => blue.id == player.id) == 0 && inChooseMode && teamB.length < teamR.length) {
		choosePlayer();
		capLeft = true; setTimeout(() => { capLeft = false; }, 10);
	}
	setActivity(player, 0);
    updateRoleOnPlayerOut();
}

// Function that is triggered when a player is kicked
room.onPlayerKicked = function(kickedPlayer, reason, ban, byPlayer) {
	ban == true ? banList.push([kickedPlayer.name, kickedPlayer.id]) : null;
}


// onPlayerChat.js
// Function that is triggered when a player chats
room.onPlayerChat = function (player, message) {

	console.log("Nombre " + player.name + " : " + message);

const spamThreshold = 5000; // Tiempo en ms para reiniciar contador
const maxMsgs = 3; // Nº de mensajes máximos permitidos en ese intervalo

let p = extendedP.find(p => p[eP.ID] === player.id);
if (p && !player.admin) {
  const now = Date.now();
  if (now - p[eP.LASTMSG] < spamThreshold) {
    p[eP.COUNT]++;
    if (p[eP.COUNT] > maxMsgs) {
      room.kickPlayer(player.id, "DEJA EL SPAM PORFA :(", false);
      return false;
    }
  } else {
    p[eP.LASTMSG] = now;
    p[eP.COUNT] = 1;
  }
}
	if (message.startsWith("t "))
	{
	room.getPlayerList().filter(callback => callback.team == player.team).forEach(callback => {room.sendAnnouncement("[Chat de equipo] " + player.name + ": " + message.substr(2)/*`[Chat de equipo] > [${player.id}] ${player.name}: ${message.substr(prefixTeamChatString.length)}`*/, callback.id, player.team == 1 ? 0xFA7878 : player.team == 0 ? 0xABFFB6 : 0x00BFFF, "bold", 1)})

	return false;
	}

	else if (message.startsWith("!say ") && player.admin == true)
	{
		room.sendAnnouncement("Mensaje Anonimo: " + message.substr(5), null, 0xffde2e, "bold", 1);
		return false;
	}
	message = message.split(/ +/);

	player.team != Team.SPECTATORS ? setActivity(player, 0) : null;

	if (["!help"].includes(message[0].toLowerCase()))
	{
		room.sendAnnouncement(" Comandos : !me, t [chat para team], !dc, !tabla, !elo, !afk, !bb ", player.id, 0x32BBED, "bold", 2);
		player.admin ? room.sendAnnouncement(Bot + " : [Admin] !mute <#id> y duración <minutos>, !unmute all/#<id>, !clearbans <number = all>", player.id, 0xC390FC, "bold", 2) : null;
				player.admin ? room.sendAnnouncement(Bot + " : [Admin] | !color <htmlcolor> | !emoji <emoji>", player.id, 0xC390FC, "bold", 2) : null;
	}

    else if (message == "!elo")
    {
        var stats;
		localStorage.getItem(getAuth(player)) ? stats = JSON.parse(localStorage.getItem(getAuth(player))) : stats = [0, 0, 0, 0, "0.00", 0, 0, 0, 0, "0.00", 0, "player", player.name, "", "", ""]
		room.sendAnnouncement("[" + player.name + "] ELO: " + stats[Ss.ELO], player.id, 0x4ffaff, "bold", 1);
	}

 else if (["!tabla"].includes(message[0].toLowerCase()))
    {
        var top10Array = [];
		let limit = 10;
        for (let key in localStorage) {

			if (key.length > 15)
			{
			// Stats: "Auth" : '["0-Games", "1-Wins", "2-Draws", "3-Losses", "4-Winrate", "5-Goals", "6-Assists", "7-GK", "8-CS", "9-CS%", "10- ELO", "11-Role", "12-Nick", "13-Emoji", "14-Color", "15-MSG"]'
			localStorage.getItem(key) ? stats = JSON.parse(localStorage.getItem(key)) : stats = [0, 0, 0, 0, "0.00", 0, 0, 0, 0, "0.00", 0, "player", player.name, "", "", ""]
            top10Array.push({ name: stats[12], elo: stats[10] });
			}
		}
        // Create items array
  		top10Array.sort((a, b) => b.elo - a.elo);

        room.sendAnnouncement("-------------TOP MUNDIAL DE FUTSAL CON ARDILLA-------------", player.id, 0xFCEC08, "bold", 2);

		if (message.length > 1) {limit = parseInt(message[1]);}

        for (var i = 0; i < Math.min(top10Array.length, limit); i++)
        {
            room.sendAnnouncement(i+1 + ". " + top10Array[i].name + " -> " + top10Array[i].elo + " puntos", player.id, 0xFCEC08, "normal", 2);
        }
	}

	else if (message == "!dc" || message == "!dc"){
        // Example of rules lol
		room.sendAnnouncement("https://discord.gg/qg3PKnXkHA", player.id, 0xf4AAB32, "bold", 2);
	}
	else if (["!afk"].includes(message[0].toLowerCase())) {
		if (players.length != 1 && player.team != Team.SPECTATORS) {
			if (player.team == Team.RED && streak > 0 && room.getScores() == null) {
				room.setPlayerTeam(player.id, Team.SPECTATORS);
			}
			else {
				room.sendAnnouncement(Bot + "No puedes ser AFK mientras estás en un equipo !", player.id, 0x8AFFF7, "bold", 1);
				return false;
			}
		}
		else if (players.length == 1 && !getAFK(player)) {
			room.setPlayerTeam(player.id, Team.SPECTATORS);
		}
		setAFK(player, !getAFK(player));
        // AFK message when command activated lol
		room.sendAnnouncement(player.name + (getAFK(player) ? " se fue a pajearse!" : " ya regresó de la paja!"), null, (getAFK(player) ? 0xFFE063 : 0xFFE063), "normal", 1);
		/*room.sendAnnouncement(player.name + (getAFK(player) ? " se fue a pajearse! " : " ya regresó de la paja! ."), null, 0xFFE063, "bold", 2);*/
		getAFK(player) ? updateRoleOnPlayerOut() : updateRoleOnPlayerIn();
	}
	else if (["!afks"].includes(message[0].toLowerCase())) {
		var cstm = " Lista de AFK : ";
		for (var i = 0; i < extendedP.length; i++) {
			if (room.getPlayer(extendedP[i][eP.ID]) != null && getAFK(room.getPlayer(extendedP[i][eP.ID]))) {
				if (140 - cstm.length < (room.getPlayer(extendedP[i][eP.ID]).name + ", ").length) {
					room.sendAnnouncement(cstm, player.id, 0x30FF91, "bold", 2);
					cstm = "... ";
				}
				cstm += room.getPlayer(extendedP[i][eP.ID]).name + ", ";
			}
		}
		if (cstm == " Lista de AFK : ") {
			room.sendAnnouncement(Bot + " No hay nadie en la lista de AFK !", player.id, 0x30FF91, "bold", 2);
			return false;
		}
		cstm = cstm.substring(0, cstm.length - 2);
		cstm += ".";
		room.sendAnnouncement(Bot + cstm, player.id, 0x8AFFF7, "bold", 2);
	}
	else if (["!me"].includes(message[0].toLowerCase())) {

		var stats;
		localStorage.getItem(getAuth(player)) ? stats = JSON.parse(localStorage.getItem(getAuth(player))) : stats = [0, 0, 0, 0, "0.00", 0, 0, 0, 0, "0.00", 0, "player", player.name, "", "", ""];
		room.sendAnnouncement("[" + player.name + "] PJ: " + stats[Ss.GA] + ", Victorias: " + stats[Ss.WI] + ", Derrotas: " + stats[Ss.LS] + ", WR: " + stats[Ss.WR] + "%, Goles: " + stats[Ss.GL] + ", Asistencias: " + stats[Ss.AS] + ", GK: " + stats[Ss.GK] + ", CS: " + stats[Ss.CS] + ", CS%: " + stats[Ss.CP] + "%", player.id, 0x30FF91, "bold", 1);

	}

	// Entry admin emoji setting
	else if ((["!emoji"].includes(message[0].toLowerCase())) && player.admin == true)  {

		if (message.length > 0)
		{

		var stats;
		localStorage.getItem(getAuth(player)) ? stats = JSON.parse(localStorage.getItem(getAuth(player))) : stats = [0, 0, 0, 0, "0.00", 0, 0, 0, 0, "0.00", 0, "player", player.name, "", "", ""];
		stats[Ss.EMOJI] = message[1];
		localStorage.setItem(getAuth(player), JSON.stringify(stats));
		room.sendAnnouncement(Bot + "Emoji del jugador cambiado exitosamente a  [ " + message[1] + " ]", player.id, 0x6FE35D, "bold", 1);
		}
	}

	else if ((["!color"].includes(message[0].toLowerCase())) && player.admin  == true) {

		if (message.length > 0)
		{
		var stats;
		localStorage.getItem(getAuth(player)) ? stats = JSON.parse(localStorage.getItem(getAuth(player))) : stats = [0, 0, 0, 0, "0.00", 0, 0, 0, 0, "0.00", 0, "player", player.name, "", "", ""];
		stats[Ss.COLOR] = message[1];
		localStorage.setItem(getAuth(player), JSON.stringify(stats));
		room.sendAnnouncement(Bot + "Color del jugador cambiado exitosamente a  [ " + message[1] + " ]", player.id, 0x6FE35D, "bold", 1);
		}
	}
	else if (["!a"].includes(message[0].toLowerCase())) {
    console.log("admin");
    if (message[1] == adminPassword) {
        room.setPlayerAdmin(player.id, true);
    }
}
	else if (["!mutes"].includes(message[0].toLowerCase())) {
		var cstm = " Lista de muteados : ";
		for (var i = 0; i < extendedP.length; i++) {
			if (room.getPlayer(extendedP[i][eP.ID]) != null && getMute(room.getPlayer(extendedP[i][eP.ID]))) {
				if (140 - cstm.length < (room.getPlayer(extendedP[i][eP.ID]).name + "[" + (extendedP[i][eP.ID]) + "], ").length) {
					room.sendAnnouncement(Bot + cstm, player.id, 0x8AFFF7, "bold", 2);
					cstm = "... ";
				}
				cstm += room.getPlayer(extendedP[i][eP.ID]).name + "[" + (extendedP[i][eP.ID]) + "], ";
			}
		}
		if (cstm == " Lista de Muteados : ") {
			room.sendAnnouncement(Bot + " No hay nadie en la lista de muteados !", player.id, 0x8AFFF7, "bold", 2);
			return false;
		}
		cstm = cstm.substring(0, cstm.length - 2);
		cstm += ".";
		room.sendAnnouncement(cstm, player.id, 0x4ffaff, "bold", 2);
	}
	else if (["!mute"].includes(message[0].toLowerCase())) {
		if (player.admin) {
			updateTeams();
			var timeOut;
			if (!Number.isNaN(Number.parseInt(message[1])) && message.length > 1) {
				if (Number.parseInt(message[1]) > 0) {
					timeOut = Number.parseInt(message[1]) * 60 * 1000;
				}
				else {
					timeOut = 10 * 60 * 1000;
				}
				if (message[2].length > 1 && message[2][0] == "#") {
					message[2] = message[2].substring(1, message[2].length);
					if (!Number.isNaN(Number.parseInt(message[2])) && room.getPlayer(Number.parseInt(message[2])) != null) {
						if (room.getPlayer(Number.parseInt(message[2])).admin || getMute(room.getPlayer(Number.parseInt(message[2])))) {
							return false;
						}
						setTimeout(function (player) { setMute(player, false); }, timeOut, room.getPlayer(Number.parseInt(message[2])));
						setMute(room.getPlayer(Number.parseInt(message[2])), true);
						room.sendChat(room.getPlayer(Number.parseInt(message[2])).name + " ha sido muteado por " + (timeOut / 100000) + " minutos !", player.id);
					}
				}
			}
			else if (Number.isNaN(Number.parseInt(message[1]))) {
				if (message[1].length > 1 && message[1][0] == "#") {
					message[1] = message[1].substring(1, message[1].length);
					if (!Number.isNaN(Number.parseInt(message[1])) && room.getPlayer(Number.parseInt(message[1])) != null) {
						if (room.getPlayer(Number.parseInt(message[1])).admin || getMute(room.getPlayer(Number.parseInt(message[1])))) {
							return false;
						}
						setTimeout(function (player) { setMute(player, false); }, 3 * 60 * 1000, room.getPlayer(Number.parseInt(message[1])));
						setMute(room.getPlayer(Number.parseInt(message[1])), true);
						room.sendChat(room.getPlayer(Number.parseInt(message[1])).name + " Lo has silenciado por 10 minutos!", player.id);
					}
				}
			}
		}
	}
	else if (["!unmute"].includes(message[0].toLowerCase())) {
		if (player.admin && message.length >= 2) {
			if (message[1] == "all") {
				extendedP.forEach((ePlayer) => { ePlayer[eP.MUTE] = false; });
				room.sendChat("Se ha limpiado la lista de muteados", player.id);
			}
			else if (Number.isNaN(Number.parseInt(message[1]))) {
				if (message[1].length > 1 && message[1][0] == "#") {
					message[1] = message[1].substring(1, message[1].length);
					if (!Number.isNaN(Number.parseInt(message[1])) && room.getPlayer(Number.parseInt(message[1])) != null && getMute(room.getPlayer(Number.parseInt(message[1])))) {
						setMute(room.getPlayer(Number.parseInt(message[1])), false);
						room.sendChat(room.getPlayer(Number.parseInt(message[1])).name + " ¡Ya puede volver a hablar!", player.id);
					}
				}
			}
		}
	}

	else if (["!bans"].includes(message[0].toLowerCase())) {
		if (banList.length == 0) {
			room.sendAnnouncement("No hay nadie en la lista de baneados!", player.id, 0xFFFFFF, "bold", 1);
			return false;
		}
		var cstm = "Lista de baneados : ";
		for (var i = 0; i < banList.length; i++) {
			if (140 - cstm.length < (banList[i][0] + "[" + (banList[i][1]) + "], ").length) {
				room.sendAnnouncement(cstm, player.id);
				cstm = "... ";
			}
			cstm += banList[i][0] + "[" + (banList[i][1]) + "], ";
		}
		cstm = cstm.substring(0, cstm.length - 2);
		cstm += ".";
		room.sendAnnouncement(cstm, player.id);
	}
	else if (["!cb"].includes(message[0].toLowerCase())) {
	if (player.admin) {
		if (message.length == 1) {
			room.clearBans();
			room.sendAnnouncement("Todos los baneos han sido eliminados.", player.id);
			banList = [];
		} else if (message.length == 2) {
			const ID = Number.parseInt(message[1]);
			if (!Number.isNaN(ID) && ID > 0) {
				const target = banList.find(p => p[1] == ID);
				if (target) {
					room.clearBan(ID);
					room.sendAnnouncement(`${target[0]} ha sido desbaneado.`, player.id);
					banList = banList.filter(p => p[1] != ID);
				} else {
					room.sendAnnouncement("⚠️ Ese ID no está en la lista de baneados.", player.id);
				}
			}
		}
	}
}

	else if (["!bb",].includes(message[0].toLowerCase())) {
		room.kickPlayer(player.id, "Nos vemos, espero regreses <3", false);
	}

	if (teamR.length != 0 && teamB.length != 0 && inChooseMode) {
		if (player.id == teamR[0].id || player.id == teamB[0].id) { // we care if it's one of the captains choosing
			if (teamR.length <= teamB.length && player.id == teamR[0].id) { // we care if it's red turn && red cap talking
				if (["top"].includes(message[0].toLowerCase())) {
					room.setPlayerTeam(teamS[0].id, Team.RED);
					redCaptainChoice = "top";
					clearTimeout(timeOutCap);
					room.sendAnnouncement(player.name + " elegiste Top !");
					return false;
				}
				else if (["random"].includes(message[0].toLowerCase())) {
					var r = getRandomInt(teamS.length);
					room.setPlayerTeam(teamS[r].id, Team.RED);
					redCaptainChoice = "random";
					clearTimeout(timeOutCap);
					room.sendAnnouncement(player.name + " elegiste Random !");
					return false;
				}
				else if (!Number.isNaN(Number.parseInt(message[0]))) {
					if (Number.parseInt(message[0]) > teamS.length || Number.parseInt(message[0]) < 1) {
						room.sendAnnouncement("El número que elegiste es inválido !", player.id);
						return false;
					}
					else {
						room.setPlayerTeam(teamS[Number.parseInt(message[0]) - 1].id, Team.RED);
						room.sendAnnouncement(player.name + " eligió a " + teamS[Number.parseInt(message[0]) - 1].name + " !", 0x4ffaff, "bold", 1);
						return false;
					}
				}
			}
			if (teamR.length > teamB.length && player.id == teamB[0].id) { // we care if it's red turn && red cap talking
				if (["top", "auto"].includes(message[0].toLowerCase())) {
					room.setPlayerTeam(teamS[0].id, Team.BLUE);
					blueCaptainChoice = "top";
					clearTimeout(timeOutCap);
					room.sendAnnouncement(player.name + " seleccionó Top !");
					return false;
				}
				else if (["random", "rand"].includes(message[0].toLowerCase())) {
					room.setPlayerTeam(teamS[getRandomInt(teamS.length)].id, Team.BLUE);
					blueCaptainChoice = "random";
					clearTimeout(timeOutCap);
					room.sendAnnouncement(player.name + " seleccionó Random !");
					return false;
				}
				else if (!Number.isNaN(Number.parseInt(message[0]))) {
					if (Number.parseInt(message[0]) > teamS.length || Number.parseInt(message[0]) < 1) {
						room.sendAnnouncement("El número que elegiste es inválido !", player.id);
						return false;
					}
					else {
						room.setPlayerTeam(teamS[Number.parseInt(message[0]) - 1].id, Team.BLUE);
						room.sendAnnouncement(player.name + " eligió " + teamS[Number.parseInt(message[0]) - 1].name + " !", 0x4ffaff, "bold", 1);
						return false;
					}
				}
			}

		}

	}
	if (message[0][0] == "!") {
		return false;
	}
	if (getMute(player)) {
		room.sendAnnouncement("estas muteado pq te portaste mal.", player.id);
		return false;
	}

    // Special chat settings for Admin and specific players (Using nicks)
	else if (player.admin && player.name != botName) {
		var stats;
		localStorage.getItem(getAuth(player)) ? stats = JSON.parse(localStorage.getItem(getAuth(player))) : stats = [0, 0, 0, 0, "0.00", 0, 0, 0, 0, "0.00", 0, "player", player.name, "", "", ""];
		room.sendAnnouncement("[" + stats[Ss.EMOJI] + "] " + player.name + ": " + message.join(" "), null, "0x" + stats[Ss.COLOR] , "bold", 1);
		return false;
	}

	else if (!player.admin) {
			room.sendAnnouncement((player.team == 1 ? "♻│" + player.name + ": " + message.join(" ") : player.team == 0 ? "♻│"  + player.name + ": " + message.join(" ") : "♻│" + player.name + ": " + message.join(" ")), null , player.team == 1 ? 0xFA7878 : player.team == 0 ? 0xFFD700: 0x00BFFF, "normal", 1);
			return false;

	}

}

room.onPlayerActivity = function(player) {
	setActivity(player, 0);
}


// onPlayerBallKick.js
room.onPlayerBallKick = function(player) {
	if (lastPlayersTouched[0] == null || player.id != lastPlayersTouched[0].id) {
		!activePlay ? activePlay = true : null;
		lastTeamTouched = player.team;
		lastPlayersTouched[1] = lastPlayersTouched[0];
		lastPlayersTouched[0] = player;
	}
}


// gameManagement.js
room.onGameStart = function(byPlayer) {
	game = new Game(Date.now(), room.getScores(), []);
	countAFK = true;
	activePlay = false;
	goldenGoal = false;
	endGameVariable = false;
	lastPlayersTouched = [null, null];
    Rposs = 0;
	Bposs = 0;
	GKList = [];
	allReds = [];
	allBlues = [];
	if (teamR.length == maxTeamSize && teamB.length == maxTeamSize) {
		for (var i = 0; i < maxTeamSize; i++) {
			allReds.push(teamR[i]);
			allBlues.push(teamB[i]);
		}
	}
	for (var i = 0; i < extendedP.length; i++) {
		extendedP[i][eP.GK] = 0;
		extendedP[i][eP.ACT] = 0;
		room.getPlayer(extendedP[i][eP.ID]) == null ? extendedP.splice(i, 1) : null;
	}
	deactivateChooseMode();
	reset_size(player_size);

}

room.onGameStop = function(byPlayer) {
    if (byPlayer.id !== 0 || !endGameVariable) return;

    updateTeams();

    if (inChooseMode) {
        if (players.length === 2 * maxTeamSize) {
            inChooseMode = false;
            resetBtn();
            for (let i = 0; i < maxTeamSize; i++) {
                setTimeout(() => randomBtn(), 400 * i);
            }
            setTimeout(() => room.startGame(), 2000);
        } else {
            lastWinner === Team.RED ? blueToSpecBtn()
            : lastWinner === Team.BLUE ? (redToSpecBtn(), blueToRedBtn())
            : resetBtn();

            setTimeout(() => topBtn(), 500);
        }
    } else {
        const playerCount = players.length;

        if (playerCount === 2) {
            if (lastWinner === Team.BLUE) {
                room.setPlayerTeam(teamB[0].id, Team.RED);
                room.setPlayerTeam(teamR[0].id, Team.BLUE);
            }
            setTimeout(() => room.startGame(), 2000);

        } else if ([3, 5].includes(playerCount) || playerCount >= 2 * maxTeamSize + 1) {
            lastWinner === Team.RED ? blueToSpecBtn()
            : (redToSpecBtn(), blueToRedBtn());

            setTimeout(() => topBtn(), 200);

            if (playerCount === 5 || playerCount >= 2 * maxTeamSize + 1) {
                activateChooseMode();
            } else {
                setTimeout(() => room.startGame(), 2000);
            }

        } else if (playerCount === 4) {
            resetBtn();
            setTimeout(() => {
                randomBtn();
                setTimeout(() => randomBtn(), 500);
            }, 500);
            setTimeout(() => room.startGame(), 2000);

        } else if (playerCount === 6) {
            resetBtn();
            setTimeout(() => {
                randomBtn();
                setTimeout(() => {
                    randomBtn();
                    setTimeout(() => randomBtn(), 500);
                }, 500);
            }, 500);
            setTimeout(() => room.startGame(), 2000);
        }
    }
}


function change_size(player_size, team) {

	var players = room.getPlayerList();
	var team_players = players.filter((p) => p.team == team);
	for (var i = 0; i < team_players.length; i++) {
		room.setPlayerDiscProperties(team_players[i].id, {radius: player_size});
	}

}

function reset_size(player_size) {

	var players = room.getPlayerList();
	for (var i = 0; i < players.length; i++) {
		room.setPlayerDiscProperties(players[i].id, {radius: player_size});
	}
}


room.onGamePause = function(byPlayer) {
}

room.onGameUnpause = function (byPlayer) {
	if (teamR.length == 4 && teamB.length == 4 && inChooseMode || (teamR.length == teamB.length && teamS.length < 2 && inChooseMode)) {
		deactivateChooseMode();
	}
}

room.onRoomLink = function(url) {
}

room.onPlayerAdminChange = function (changedPlayer, byPlayer) {
	if (getMute(changedPlayer) && changedPlayer.admin) {
		room.sendAnnouncement(changedPlayer.name + " ha sido desmuteado.");
		setMute(changedPlayer, false);
	}
}


room.onGameTick = function() {
	checkTime();
	getLastTouchOfTheBall();
	getStats();
	handleInactivity();
}


// onTeamGoal.js
room.onTeamGoal = function(team) {
	activePlay = false;
	countAFK = false;
	const scores = room.getScores();
	game.scores = scores;
	if (lastPlayersTouched[0] != null && lastPlayersTouched[0].team == team) {
		
		if (lastPlayersTouched[1] != null && lastPlayersTouched[1].team == team) {
			room.sendAnnouncement("✓" + " Golazo de " + lastPlayersTouched[0].name + " ! Con paseson de " + lastPlayersTouched[1].name + "│ Velocidad de tiro: " + ballSpeed.toPrecision(3).toString() + "km/h " + (team == Team.RED ? "­" : "­"), null, 0x40C418, "bold", 1);
			game.goals.push(new Goal(scores.time, team, lastPlayersTouched[0], lastPlayersTouched[1]));

		}
		else {
			room.sendAnnouncement("✓" + " Golazo de " + lastPlayersTouched[0].name + "│ Velocidad de tiro : " + ballSpeed.toPrecision(3).toString() + "km/h " + (team == Team.RED ? "­" : "­"), null, 0x40C418, "bold", 1);
			game.goals.push(new Goal(scores.time, team, lastPlayersTouched[0], null));
			
		}

		change_size(15, team);

	}
	else {
		room.sendAnnouncement("✘ " + " " + lastPlayersTouched[0].name + " pero q haces??? "+ " │ Velocidad de la cagada : " + ballSpeed.toPrecision(3).toString() + "km/h " + (team == Team.RED ? "­" : "­"), null, 0xFA7878, "bold", 1);
		game.goals.push(new Goal(scores.time, team, null, null));
	}
	if (scores.scoreLimit != 0 && (scores.red == scores.scoreLimit || scores.blue == scores.scoreLimit && scores.blue > 0 || goldenGoal == true)) {
		endGame(team);
		goldenGoal = false;
		setTimeout(() => { room.stopGame(); }, 1000);
	}
}

room.onPositionsReset = function() {
	countAFK = true;
	lastPlayersTouched = [null, null];
	reset_size(player_size);
}
